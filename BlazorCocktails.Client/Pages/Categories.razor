@page "/categories"
@using API.APIService
@using System.Linq
@using BlazorCocktails.Client.Shared
@inject APIClient Api
@inject ISnackbar Snackbar
@inject NavigationManager Nav
@inject Microsoft.Extensions.Localization.IStringLocalizer<App> L

<PageTitle>@L["Categories_Title"]</PageTitle>

<MudStack Spacing="2">

    @if (categories is null)
    {
        <MudProgressLinear Indeterminate="true" Class="mb-4" />
    }
    else
    {
        <MudSelect T="string"
                   Label="@L["Categories_Label"]"
                   Dense="true"
                   Clearable="true"
                   Placeholder="@L["Categories_Placeholder"]"
                   Value="selectedCategory"
                   ValueChanged="OnCategoryChanged"
                   Immediate="true"
                   Disabled="@isLoading">
            @foreach (var c in categories)
            {
                <MudSelectItem Value="@c.StrCategory">
                    @DisplayCategory(c.StrCategory)
                </MudSelectItem>
            }
        </MudSelect>
    }

    @if (isLoading)
    {
        <MudProgressCircular Indeterminate="true" Class="mt-2" />
    }
    else if (drinks is null)
    {
        <MudText Class="mt-4" Color="Color.Secondary">
            @L["Categories_SelectHint"]
        </MudText>
    }
    else
    {
        @if (drinks.Count > pageSize)
        {
            <Pager TotalItems="drinks.Count"
                   PageSize="pageSize"
                   Radius="2"
                   @bind-CurrentPage="page" />
        }

        <MudGrid Class="mt-2">
            @foreach (var drink in PagedDrinks)
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Class="mb-4 hover-elevate" Style="cursor:pointer"
                     @onclick="@(() => Nav.NavigateTo($"/cocktail/{drink.IdDrink}?from=categories"))">
                        <MudCardMedia Image="@drink.StrDrinkThumb" Height="160" Alt="@drink.StrDrink" />
                        <MudCardContent>
                            <MudText Typo="Typo.subtitle2">@drink.StrDrink</MudText>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
</MudStack>

@code {
    List<CategoryDTO>? categories;
    string? selectedCategory;

    List<CocktailItemDTO>? drinks;
    bool isLoading;
    long lastRequestId;
    int page = 1;
    const int pageSize = 8;

    IEnumerable<CocktailItemDTO> PagedDrinks =>
        (drinks ?? Enumerable.Empty<CocktailItemDTO>())
            .Skip((page - 1) * pageSize)
            .Take(pageSize);

    protected override async Task OnInitializedAsync()
    {
        try
        {
            categories = (await Api.Cocktails_GetCategoriesAsync())?.ToList();
        }
        catch (ApiException ex)
        {
            Snackbar.Add($"{L["Categories_Error_LoadCategories"]}: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnCategoryChanged(string? value)
    {
        selectedCategory = value;
        page = 1;

        if (string.IsNullOrWhiteSpace(selectedCategory))
        {
            drinks = null;
            StateHasChanged();
            return;
        }

        drinks = null;
        isLoading = true;
        StateHasChanged();
        var reqId = Interlocked.Increment(ref lastRequestId);

        try
        {
            var result = (await Api.Cocktails_GetByCategoryAsync(selectedCategory))?.ToList();
            if (reqId != lastRequestId) return;
            drinks = result ?? new();
        }
        catch (ApiException ex)
        {
            if (reqId == lastRequestId)
            {
                Snackbar.Add($"{L["Categories_Error_LoadDrinks"]}: {ex.Message}", Severity.Error);
                drinks = new();
            }
        }
        finally
        {
            if (reqId == lastRequestId)
            {
                isLoading = false;
                StateHasChanged();
            }
        }
    }

    private string DisplayCategory(string? apiValue)
    {
        var key = (apiValue ?? "").Trim().ToLowerInvariant() switch
        {
            "ordinary drink" => "Category_OrdinaryDrink",
            "cocktail" => "Category_Cocktail",
            "shake" => "Category_MilkFloatShake",
            "other / unknown" => "Category_OtherUnknown",
            "cocoa" => "Category_Cocoa",
            "shot" => "Category_Shot",
            "coffee / tea" => "Category_CoffeeTea",
            "homemade liqueur" => "Category_HomemadeLiqueur",
            "punch / party drink" => "Category_PunchPartyDrink",
            "beer" => "Category_Beer",
            "soft drink" => "Category_SoftDrink",
            _ => apiValue ?? ""
        };
        return L[key];
    }
}

@*
 Qué hacemos:
  - Listamos cócteles filtrables por **categoría** y mostramos los resultados en tarjetas con paginación.

 UI:
  - <MudSelect> para elegir categoría (clearable, Immediate, placeholder).
  - Indicadores de carga: <MudProgressLinear> (categorías) y <MudProgressCircular> (cócteles).
  - Grid de <MudCard> con imagen/título; al hacer clic navegamos a /cocktail/{id}?from=categories.
  - <Pager> cuando superamos pageSize (8).

 Flujo:
  - OnInitializedAsync(): cargamos categorías con Api.Cocktails_GetCategoriesAsync().
  - OnCategoryChanged(): actualizamos selección, reiniciamos página, limpiamos lista si se deselecciona y pedimos cócteles de la categoría.

 Concurrencia y estado:
  - Controlamos peticiones con lastRequestId para ignorar respuestas tardías.
  - Manejamos isLoading y forzamos StateHasChanged() cuando toca.
  - PagedDrinks aplica Skip/Take según la página actual.

 Localización y errores:
  - Usamos IStringLocalizer<App> para todos los textos y Snackbar para errores.
  - DisplayCategory() mapea el valor de la API a claves .resx (ej.: "ordinary drink" -> "Category_OrdinaryDrink").

 Notas:
  - pageSize = 8 (constante).
  - Si se deselecciona la categoría, dejamos drinks = null para mostrar el hint.
*@
