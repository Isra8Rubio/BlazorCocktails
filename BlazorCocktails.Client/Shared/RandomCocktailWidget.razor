@using API.APIService
@using Microsoft.Extensions.Localization
@implements IAsyncDisposable
@inject APIClient Api
@inject ISnackbar Snackbar
@inject IStringLocalizer<App> L
@inject NavigationManager Nav

<MudPaper Elevation="1" Class="pa-4">
    <MudStack Direction="Row" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-2">
        <MudText Typo="Typo.h6">@L["Random_Title", "🍹"]</MudText>

        <MudButton Variant="Variant.Outlined"
                   StartIcon="@Icons.Material.Filled.Refresh"
                   Disabled="@refreshing"
                   OnClick="RefreshAsync">
            @L["Random_Refresh"]
        </MudButton>
    </MudStack>

    @if (loading)
    {
        <MudSkeleton Height="120" />
    }
    else if (row is null)
    {
        <MudText Color="Color.Secondary">@L["Random_NoData"]</MudText>
    }
    else
    {
        <MudLink Href="@($"/cocktail/{row.DrinkId}")"
                 Style="display:inline-block; text-decoration:none; color:inherit;">
            <MudCard Class="hover-elevate cursor-pointer" Style="max-width: 520px;">
                <MudCardMedia Image="@row.ThumbUrl" Height="180" Alt="@row.Name" />
                <MudCardContent>
                    <MudText Typo="Typo.subtitle1">@row.Name</MudText>
                </MudCardContent>
            </MudCard>
        </MudLink>
    }
</MudPaper>

@code {
    private RandomCocktailDTO? row;
    private bool loading = true;
    private bool refreshing;
    private PeriodicTimer? _timer;
    private CancellationTokenSource? _cts;

    protected override async Task OnInitializedAsync()
    {
        loading = true;
        try
        {
            // Carga inicial (lee lo que ya dejó el hosted service en BD)
            row = await Api.Cocktails_GetRandomRowAsync();
        }
        catch (ApiException ex)
        {
            Snackbar.Add($"Error cargando: {ex.Message}", Severity.Error);
        }
        finally
        {
            loading = false;
        }

        // Iniciar bucle de auto-actualización cada 12 segundos
        _cts = new CancellationTokenSource();
        _timer = new PeriodicTimer(TimeSpan.FromSeconds(12));

        _ = RunAutoRefreshLoopAsync(_cts.Token);
    }

    private async Task RunAutoRefreshLoopAsync(CancellationToken ct)
    {
        try
        {
            while (await _timer!.WaitForNextTickAsync(ct))
            {
                try
                {
                    // Lee el último "random" guardado
                    var latest = await Api.Cocktails_GetRandomRowAsync();

                    if (latest?.DrinkId != row?.DrinkId)
                    {
                        row = latest;
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch (ApiException ex)
                {
                    Snackbar.Add($"Auto-refresh: {ex.Message}", Severity.Warning);
                }
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private async Task RefreshAsync()
    {
        refreshing = true;
        try
        {
            row = await Api.Cocktails_RefreshRandomNowAsync();
            Snackbar.Add("¡Actualizado!", Severity.Success);
        }
        catch (ApiException ex)
        {
            Snackbar.Add($"Error refrescando: {ex.Message}", Severity.Error);
        }
        finally
        {
            refreshing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void GoToDetail()
    {
        if (!string.IsNullOrWhiteSpace(row?.DrinkId))
            Nav.NavigateTo($"/cocktail/{row!.DrinkId}");
    }

    public async ValueTask DisposeAsync()
    {
        _cts?.Cancel();
        _timer?.Dispose();
        _cts?.Dispose();
        await Task.CompletedTask;
    }
}

@*
 Qué hacemos:
  - Mostramos un cóctel aleatorio con opción de refrescar manualmente y **auto-actualización cada 12s**.
  - Al hacer clic en la tarjeta, navegamos al detalle del cóctel.

 Flujo:
  - OnInitializedAsync(): cargamos el registro actual (Cocktails_GetRandomRowAsync) y
    arrancamos un bucle con PeriodicTimer(12s) + CancellationToken.
  - En cada tick comparamos el nuevo DrinkId con el actual; si cambia, actualizamos el estado.
  - El botón "Refrescar" llama Cocktails_RefreshRandomNowAsync y vuelve a pintar.

 UI:
  - <MudPaper> con header (título + botón refresh con loading/disabled).
  - Skeleton mientras cargamos; si no hay datos, mostramos "Random_NoData".
  - Tarjeta clicable (MudLink) con imagen 16:9 y nombre del cóctel.

 Estado/errores:
  - Campos: row, loading, refreshing, _timer, _cts.
  - Mostramos errores/avisos vía Snackbar (carga inicial, auto-refresh y manual).

 Limpieza:
  - Implementamos IAsyncDisposable: cancelamos el token y liberamos el timer en DisposeAsync().

 Localización:
  - Usamos IStringLocalizer<App> (L) para títulos, textos y mensajes.
*@
