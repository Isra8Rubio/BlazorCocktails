@using API.APIService
@using Microsoft.Extensions.Localization
@using MudBlazor

@inject APIClient Api
@inject IStringLocalizer<App> L
@inject ISnackbar Snackbar

<MudPaper Class="pa-4">
    <MudStack Spacing="2">
        <MudText Typo="Typo.h6">@Title</MudText>

        @if (loading)
        {
            <MudProgressLinear Indeterminate="true" />
        }
        else if (series is null || labels is null || series.Length == 0)
        {
            <MudText Color="Color.Secondary">@L["Chart_Empty"]</MudText>
        }
        else
        {
            <MudChart ChartType="ChartType.Pie"
                      InputLabels="labels"
                      InputData="series"
                      @bind-SelectedIndex="selectedIndex"
                      Width="100%"
                      Height="300px" />

            <MudText Class="mt-2" Typo="Typo.subtitle2">
                @if (selectedIndex >= 0 && labels is not null && series is not null)
                {
                    var count = series[selectedIndex];
                    var total = series.Sum();
                    var pct = total > 0 ? Math.Round(count / total * 100, 1) : 0;
                    @($"{labels[selectedIndex]}: {count:N0} ({pct}%)")
                }
                else
                {
                    @L["Chart_ClickToSelect"]
                }
            </MudText>
        }
    </MudStack>
</MudPaper>

@code {
    // --- Parámetros ---
    [Parameter] public string? Title { get; set; }

    // Nuevo nombre
    [Parameter] public int MaxSlices { get; set; } = 10;

    // Compatibilidad hacia atrás (si te olvidas y pasas TopN, lo usamos)
    [Parameter] public int? TopN { get; set; }

    // Categorías que deben mostrarse siempre
    [Parameter]
    public string[] RequiredCategories { get; set; } =
        new[] { "Cocoa", "Homemade liqueur", "Beer", "Soft Drink" };

    // --- Estado ---
    private bool loading = true;
    private string[]? labels;
    private double[]? series;
    private int selectedIndex = -1;

    protected override async Task OnParametersSetAsync()
    {
        // Si te pasan Title sin traducir, ponemos el por defecto localizado
        Title ??= L["Chart_Category_Title"].Value;

        // Back-compat: si llega TopN lo aplicamos a MaxSlices
        if (TopN.HasValue) MaxSlices = TopN.Value;

        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        loading = true;
        selectedIndex = -1;

        try
        {
            // 1) Listado de categorías
            var categories = await Api.Cocktails_GetCategoriesAsync();

            var names = categories?
                .Select(c => c.StrCategory)
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList() ?? new();

            if (names.Count == 0)
            {
                labels = Array.Empty<string>();
                series = Array.Empty<double>();
                return;
            }

            // 2) Conteo por categoría (paralelo)
            var results = await Task.WhenAll(names.Select(cat => Api.Cocktails_GetByCategoryAsync(cat)));

            var pairs = names.Zip(results, (name, list) =>
                new { Name = name, Count = (double)(list?.Count ?? 0) })
                .OrderByDescending(x => x.Count)
                .ToList();

            // 3) Selección: Required + Top hasta MaxSlices y “Otros”
            var requiredSet = new HashSet<string>(RequiredCategories.Select(Norm), StringComparer.OrdinalIgnoreCase);

            var required = pairs.Where(p => requiredSet.Contains(Norm(p.Name))).ToList();
            var remaining = pairs.Where(p => !requiredSet.Contains(Norm(p.Name)))
                                 .OrderByDescending(p => p.Count)
                                 .ToList();

            var capacityForRest = Math.Max(0, MaxSlices - required.Count);
            var pickedRest = remaining.Take(capacityForRest).ToList();
            var selected = required.Concat(pickedRest)
                                   .GroupBy(p => p.Name, StringComparer.OrdinalIgnoreCase)
                                   .Select(g => g.First())
                                   .ToList();

            var othersCount = remaining.Skip(pickedRest.Count).Sum(p => p.Count);

            // 4) Etiquetas localizadas
            var labelList = selected.Select(p => LocalizeCategory(p.Name)).ToList();
            var dataList = selected.Select(p => p.Count).ToList();

            if (othersCount > 0)
            {
                labelList.Add(L["Category_Others"].Value); // añade la traducción en ES
                dataList.Add(othersCount);
            }

            labels = labelList.ToArray();
            series = dataList.ToArray();
        }
        catch (ApiException ex)
        {
            Snackbar.Add($"Error loading categories chart: {ex.Message}", Severity.Error);
            labels = Array.Empty<string>();
            series = Array.Empty<double>();
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private static string Norm(string s) =>
        (s ?? "").Trim().ToLowerInvariant().Replace("  ", " ");

    private string LocalizeCategory(string apiName)
    {
        switch (Norm(apiName))
        {
            case "cocktail": return L["Category_Cocktail"].Value;
            case "ordinary drink": return L["Category_OrdinaryDrink"].Value;
            case "shot": return L["Category_Shot"].Value;
            case "punch / party drink": return L["Category_PunchPartyDrink"].Value;
            case "other / unknown": return L["Category_OtherUnknown"].Value;
            case "coffee / tea": return L["Category_CoffeeTea"].Value;
            case "milk / float / shake": return L["Category_MilkFloatShake"].Value;
            case "shake": return L["Category_MilkFloatShake"].Value; // alias por si llega como "Shake"
            case "homemade liqueur": return L["Category_HomemadeLiqueur"].Value;
            case "beer": return L["Category_Beer"].Value;
            case "cocoa": return L["Category_Cocoa"].Value;
            case "soft drink": return L["Category_SoftDrink"].Value;
            default: return apiName;
        }
    }
}
